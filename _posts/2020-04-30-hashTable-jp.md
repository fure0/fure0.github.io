---
layout: post
categories: "DataStructure"
title: "Hash Table"
author: "TY_K"
---

### Hash Table(ハッシュテーブル)

> ハッシュテーブルは連関配列構造を利用してキー(key)に結果値(value)を保存する資料構造

### 連関配列構造(associative array)とは、

キー(key) 1個と値(value) 1個が1:1で関連している資料構造である。 したがってキー(key)を用いて値(value)を導き出すことができる。

連関配列構造は、select、insert、edit、delete命令を支援する。

(ハッシュテーブルでも同様に適用される。)

### ハッシュテーブルの構造(Hash Table Data Structure)

![HashTable](https://user-images.githubusercontent.com/20508342/80629159-6784ce00-8a8d-11ea-9f8d-de07af7cf745.png)

### ハッシュテーブルの要素

#### 1. キー(key)

固有の値であり、ハッシュ関数のinput となる。 様々な長さの値となり得る。 この状態で最終リポジトリに保存されると、多様な長さだけのリポジトリを構成しておかなければならないため、ハッシュ関数に値を変えて保存しなければ空間の効率性を追求できない。

#### 2. ハッシュ関数(Hash Function)

キー(key)をハッシュ(hash)に置き換える役割を持つ。 様々な長さのキー(key)を一定の長さを持つハッシュ(hash)に変更し、リポジトリを効率的に運用できるようにサポートする。 ただし、異なるキー(key)が同じハッシュ(hash)となる場合をハッシュ衝突(Hash Collision)というが、ハッシュ衝突を引き起こす確率を極力減らす関数を作ることが重要である。

#### 3. ハッシュ(Hash)

ハッシュ関数(Hash Function)の結果物であり、リポジトリ(bucket、 slot)で値(value)とマッチングして保存される。

#### 4. 値(Value)

リポジトリ(bucket、slot)に最終的に保存される値でキーとマッチングされ、保存、削除、検索、アクセスが可能でなければならない。

![LinearProbing](https://user-images.githubusercontent.com/20508342/80733086-30272780-8b48-11ea-9162-19f57ca22434.jpeg)

### Insertion(保存)

ハッシュテーブルで資料を保存するためにはハッシュ関数(Hash Fucntion)でキー(key)をハッシュ(hash)に変更しなければならない。 上の写真のようにハッシュ関数がinput key を7 で割った残りに変更して出力したとき、キー(key)は"76"、ハッシュ(Hash)は"6"である。

すると、あらかじめ準備しておいた0、1、2、3、4、5、6のリポジトリ(bucket、slot)の中から適切なハッシュ(hash)値を探し出し、その値(value)を保存する。

ハッシュ関数からハッシュを算出する過程において、異なるkey が同じhash に変更される問題が生じうるが、これはkey とvalue が1:1 にマッチングされるべきであるというルールに反するものになるので、この問題を解決しながら保存されなければならない。 これはハッシュ衝突(Hash Collision)といい、ハッシュ衝突の解決については後述する。

### Insertion Big-O

保存段階の時間複雑度はO(1)である。 キー(key)は固有であり、ハッシュ関数(hash function)の結果として出たハッシュ(hash)と値をリポジトリに入れればよいためである。 このとき、ハッシュ関数の時間複雑度は併せて考慮しない。
しかし、最悪の場合O(n)になることがある。 ハッシュ衝突により、すべてのbucket のvalue を探さなければならない場合もあるからである。 これに関してもハッシュ衝突とともに後述する。

### Deletion(削除)

保存されている値を削除するときは、リポジトリで当該キーとマッチングされる値(value)を探して削除すればよい。 保存場所にはhashとvalueが一緒に保存されているので一緒に消せば良い。

### Deletion Big-O

削除段階の時間複雑度はO(1)である。 キー(key)は固有であり、ハッシュ関数(hash function)の結果として出たハッシュ(hash)にマッチングされる値(value)を削除すればよいからである。 このとき、ハッシュ関数の時間複雑度は併せて考慮しない。
しかし、最悪の場合O(n)になることがある。 ハッシュ衝突により、すべてのbucket のvalue を探さなければならない場合もあるからである。 これに関してもハッシュ衝突とともに後述する

### Search(検索)

キー(key)で値(value)を見つける過程はDeletion 過程と似ている。 

1.キーでhashを求める。 
2.hashで値(value)を探す。

### Search Big-O

検索段階の時間複雑度はO(1)である。 キー(key)は固有であり、ハッシュ関数(hash function)の結果として出たハッシュ(hash)にマッチングされる値(value)を探せばよいからである。 このとき、ハッシュ関数の時間複雑度は併せて考慮しない。
しかし、最悪の場合O(n)になることがある。 ハッシュ衝突により、すべてのbucket のvalue を探さなければならない場合もあるからである。 これに関してもハッシュ衝突とともに後述する。

### Hash Collision(ハッシュ衝突)

ハッシュテーブルはInsertion、Deletion、Searchの過程において、いずれも平均的にO(1) の時間複雑図を持っているため、資料構造の効率性の面で非常に優れていると考えられる。 しかし、このような長所だけがあるのだろうか。

ハッシュ(hash)を用いた資料構造の方式に必然的に現れうる問題は、

> 無限の値(ハッシュテーブルではKEYを意味する。)を有限な値(ハッシュテーブルではHashを意味する。)と表現しながら、異なる2つ以上の有限な値が同一の出力値を持つことになる。

次の例を見よう

![Hash Collision](https://user-images.githubusercontent.com/20508342/80735843-3ddeac00-8b4c-11ea-98ba-0dcd755fbc9c.png)

JohnとSandraのhashが同じである。 このような現象をhash collisionという。

### Collision Resolution

### 1.Separate Chaining(略してChaining)

![SeparateChaining](https://user-images.githubusercontent.com/20508342/80736308-e856cf00-8b4c-11ea-81e1-759c4fa579b3.png)

Sandraが入るのに衝突が起きると、既存のJohnの値に連結させた。
チェーニング(Chaining)は資料を保存する際、リポジトリで衝突が起きた場合、その値を従来の値と連結させる手法である。
上記の写真でSandraを保存する際に衝突が起こり、既存のJohnに連結させた。 この時、連結リスト(Linked List)資料構造を利用する。 次に保存された資料を既存の資料の次に位置させることである。

### Chaining長所と短所

#### 長所:

* 限られたリポジトリを効率的に使用できる。
* ハッシュ関数(Hash Function)を選択する重要性が相対的に少ない。
* 相対的に少ないメモリーを使う。 あらかじめスペースを取っておく必要がない。

#### 短所:

* 一つのHashに資料が引き続き接続されれば(集中現象)検索効率を下げることができる。
* 外部ストレージを使用する。
* 外部保存空間の作業を追加しなければならない。

### Chaining時間複雑度(Big-O)

複雑度を計算する前に、一つを追加するとハッシュテーブルのリポジトリの長さを"n"、キー(key)の数を"m"と仮定したとき、平均的にリポジトリで1 つのhash あたりの(m/n)個のキーが入っている。 これを"α"と定義する。

> m/n = α (1つのHash 当たり平均的にα個のキーが入っている。)

### Insertion :

衝突が起きたとき、当該ハッシュ(Hash)が持つ連結リストのHeadに資料を保存する場合、O(1)の時間複雑図を持つ。 該当ハッシュ(Hash)を算出して保存しながら、従来の値(value)を結びつける行為だけを行えば済むからだ。

反面、Tailに資料を保存する場合、O(α)の時間複雑度を有する。 当該ハッシュ(Hash)を保存する際に、すべての接続リストを通ってTail にアクセスしなければならないからである。 最悪の場合、O(n)の時間複雑度を持つ。 一つのハッシュ(Hash)にすべての資料が繋がっている可能性があるからだ。

### Deletion & Search:

削除と検索は時間の複雑さにおいて類似の概念を共有する。 算出されたHashの連結リストを順番にチェックする必要があるので、O(醫)の時間複雑度を持つ。 最悪の場合、O(α)の時間複雑度を持つ。 一つのハッシュ(Hash)にすべての資料が繋がっている可能性があるからだ。 この場合、すべての資料を調べなければならない。

![SeparateChaining2](https://user-images.githubusercontent.com/20508342/80738192-93688800-8b4f-11ea-9007-fe92db504413.png)

Hashを任意に切り替えて保存した。

### Open Addressing(開放アドレス法)

開放アドレス法はデータのハッシュ(hash)が変更されなかったchaining とは異なり、空いているハッシュ(hash)を探してデータを保存する手法である。 したがって、開放アドレス法におけるハッシュテーブルは1 つのハッシュと1 つの値(value)がマッチングされている形で保持される。

上の図を見ると、Sandraが保存されるときにハッシュがJohnで埋まっていて、その次にHashにSandraを保存した。 また、Ted のハッシュもSandra が保存されているので、その次の年時にTed を保存した。 このように空いているハッシュを探して保存する方法をOpen Addressingという。

このとき、空いているハッシュ(Hash)を探す過程は同じでなければならない。(一定の規則に従って行かなければならない。)

Open Addressing は、上述した空いているハッシュを探す規則によって次のように区分することができる。

線形探索(Linear Probing):次のハッシュ(+1)やn 個(+n)を飛ばして空いているハッシュにデータを保存する。

二乗探索(Quadratic Probing):衝突が起きたハッシュの二乗を一年目にデータを保存する。

二重ハッシュ(Double Hashing):他のハッシュ関数をもう一度適用したハッシュにデータを保存する。

### Open Addressingの長所·短所

#### 長所:

1) 他の保存スペースはなく、ハッシュテーブル内でデータ保存及び処理が可能である。

2) もうひとつの保存空間での追加作業がない。

#### 短所:

1) ハッシュ関数(Hash Function)の性能に全ハッシュテーブルの性能が左右される。

2) データの長さが伸びたら、それ相応のリポジトリを用意しておかなければならない。

### Open Addressing 時間複雑度 (Big-O)

Chaining で定義した"α"を、Open Addressing においても定義すると、ハッシュテーブルのリポジトリの長さを"n"、キー(key)の数を"m"と仮定したとき、"α"は1より小さくなる。 リポジトリ1個バケット当たり1個の値(value)だけを持つからだ。

> m/n = α (α <= 1)

### Insertion & Deletion & Search :

挿入、削除、検索など、すべて対象となるHashを探していく過程によって時間の複雑度が計算される。 ハッシュ関数を通して得られたHash が空いていなければ、次のバケットを探さなければならない。 訪れる回数が増えれば増えるほど時間の複雑度が増加する。 最上の場合はO(1)~最悪の場合(O(n))。

したがって、Open Addressing では、空いているスペースを確保すること(= リポジトリがある程度埋まったときにリポジトリのサイズを伸ばすこと)が必要である。

最悪の場合、すべてのリポジトリを点検しなければならない場合が生じかねない。(O(n))

### Last:Hash Table Data Structureの短所

* 順序のある配列には不釣り合いだ
:上下関係があったり、順序が重要なデータの場合、Hash Tableは似合わない。 順序と関係なく、キーだけを持ってhashを探して保存するからだ。

* 空間効率性が落ちる.
:データが保存される前にあらかじめ保存スペースを確保しておかなければならない。 スペースが足りない場合や埋まっていない場合が生じる可能性がある。

* Hash Function の依存度が高い。
:平均データ処理の時間複雑度はO(1) であるが、これはハッシュ関数の演算を考慮しない結果である。 ハッシュ関数が非常に複雑であれば、ハッシュテーブルの全ての演算の時間効率性は増加するだろう。

ハッシュテーブルは鍵を持って素早くvalue にアクセスし、操作できるメリットがありよく使われる。 例えば、アドレス帳の保存形態の場合、"名前+電話番号"のマッチングを利用してデータを処理する。 他の例を見つけたら、関連してポスティングをする。

[参照][DataStructure]

[DataStructure]: https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o "DataStructure"